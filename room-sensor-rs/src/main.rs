use core::pin::pin;
use core::time::Duration;

use embassy_futures::select::select;
use esp_idf_hal::gpio::Pins;
use esp_idf_hal::i2c::I2C0;
use esp_idf_hal::peripherals::Peripherals;
use esp_idf_svc::mqtt::client::QoS::AtMostOnce;
use esp_idf_svc::mqtt::client::{
    EspAsyncMqttClient, EspAsyncMqttConnection, MqttClientConfiguration,
};
use eyre::Result;
use esp_idf_svc::timer::{EspTaskTimerService, EspTimerService};

use room_rs::wifi;

use room_sensor_rs::room_sensor::Room;
use room_sensor_rs::sensor::Sensors;
use room_sensor_rs::si70xx_sensor::Si70xxSensor;
use room_sensor_rs::RoomSensorError;

fn main() -> Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_svc::sys::link_patches();

    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();

    log::info!("Sensor Room starting ...");

    let res = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap()
        .block_on(async move { start().await });
    log::info!("Main thread finished");

    res
}

async fn start() -> Result<()> {
    let peripherals = Peripherals::take().expect("Unable to take peripherals");

    let Peripherals {
        modem, pins, i2c0, ..
    } = peripherals;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = room_rs::config::CONFIG;
    let timer_service = EspTimerService::new()?;
    let mut wifi = wifi::init_wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        modem,
        &timer_service,
    )
    .await
    .expect("Unable to init wifi");

    let _ = wifi::connect_wifi(&mut wifi)
        .await
        .expect("Unable to connect wifi");

    let mqtt_config = MqttClientConfiguration::default();
    let (mut mqtt_client, mut mqtt_connection) =
        EspAsyncMqttClient::new(app_config.mqtt_host, &mqtt_config).expect("Unable to init mqtt");

    let _ = select(
        pin!(async move { mqtt_poll(&mut mqtt_connection).await }),
        pin!(async move { sensor_reads(pins, i2c0, &mut mqtt_client, &timer_service).await }),
    )
    .await;

    Ok(())
}

pub async fn mqtt_poll(
    mqtt_connection: &mut EspAsyncMqttConnection,
) -> Result<(), RoomSensorError> {
    log::info!("MQTT Listening for messages");

    while let Ok(event) = mqtt_connection.next().await {
        log::info!("[Queue] Event: {}", event.payload());
    }

    log::info!("Connection closed");

    Ok(())
}

pub async fn sensor_reads(
    pins: Pins,
    i2c0: I2C0,
    client: &mut EspAsyncMqttClient,
    timer_service: &EspTaskTimerService,
) -> Result<(), RoomSensorError> {
    let app_config = room_rs::config::CONFIG;

    let mut room = Room::new(app_config.room_name);

    let si70xx = Si70xxSensor::init(pins, i2c0)?;

    room.add_sensor(Sensors::humidity("humidity", si70xx.clone()));
    room.add_sensor(Sensors::temperature("temperature", si70xx));

    let topic_root = format!("/home/{}", room.get_name());
    let mut timer = timer_service.timer_async()?;
    timer.after(Duration::from_millis(500)).await?;

    loop {
        let sensor_values = room.collect().await;
        for sensor_value in sensor_values {
            log::info!("publish {} {:?}", sensor_value.name, sensor_value.value);
            let _ = client
                .publish(
                    &format!("{}/{}", topic_root, sensor_value.name),
                    AtMostOnce,
                    false,
                    &sensor_value.value,
                )
                .await;
        }
        timer.after(Duration::from_secs(1)).await?;
    }
}
